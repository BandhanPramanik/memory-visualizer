<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Memory and Visualization: A Visual Debugger's Guide</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Sansation:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
        <style>
        body {
            background: linear-gradient(to left, #3b82f6, #ffffff, #f97316);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }


		/* By default, the debugger view is hidden */
        .debugger-view { display: none; }
        /* When the main panel gets the 'session-active' class... */
        .panel.session-active .start-view { display: none; } /* ...hide the start view... */
        .panel.session-active .debugger-view { display: block; } /* ...and show the debugger view. */


        .content-block {
            transition: all 0.3s ease;
        }

        .content-block:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        code {
            background-color: #1f2937;
            color: #f8fafc;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
        }

        pre {
            background-color: #1f2937;
            color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }
        .sansation-light {
            font-family: "Sansation", sans-serif;
            font-weight: 300;
            font-style: normal;
        }

        .sansation-regular {
            font-family: "Sansation", sans-serif;
            font-weight: 400;
            font-style: normal;
        }

        .sansation-bold {
            font-family: "Sansation", sans-serif;
            font-weight: 700;
            font-style: normal;
        }

        .sansation-light-italic {
            font-family: "Sansation", sans-serif;
            font-weight: 300;
            font-style: italic;
        }

        .sansation-regular-italic {
            font-family: "Sansation", sans-serif;
            font-weight: 400;
            font-style: italic;
        }

        .sansation-bold-italic {
            font-family: "Sansation", sans-serif;
            font-weight: 700;
            font-style: italic;
        }

        </style>
    </head>
    <body class="py-8 px-4">
        <div class="max-w-6xl mx-auto">
            <!-- Heading -->
            <h1 class="text-4xl md:text-5xl sansation-bold text-center mb-12 text-gray-800">Memory and Visualization: A Visual Debugger's Guide</h1>

            <!-- First section (left aligned) -->
            <div class="mb-16">
                <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">What are Pointers?</h2>
                <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                    <p class="mb-4">A pointer is a variable that stores the memory address of another variable. Think of it like a house address that tells you where to find a specific house on a street.</p>

                    <p class="font-medium mb-2 text-indigo-950">Pointer as an Arrow:</p>
                    <p class="mb-4">Visually, pointers work like arrows pointing from one memory location to another. When you declare <code>int* ptr = &variable</code>, you create an arrow that points from <code>ptr</code> to wherever <code>variable</code> lives in memory.</p>

                    <p class="font-medium mb-2 text-indigo-950">Pointer as an Address:</p>
                    <p>Every memory location has a unique address, like 0x1234ABCD. A pointer simply holds this address value. When you want the data, you "follow" the address to reach the actual value stored there.</p>
                </div>
            </div>

            <!-- Zigzag pattern starts here -->
            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Null Pointer Dereferencing and Defensive Programming</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">What is Null Pointer Dereferencing?</p>
                        <p class="mb-4">A null pointer points to address 0x00000000, which is an invalid memory location. Dereferencing it (trying to access the value it points to) causes a segmentation fault.</p>

                        <p class="font-medium mb-2 text-indigo-950">Defensive Programming with Null Checks:</p>
                        <p class="mb-4">Always check if a pointer is null before using it:</p>

                        <pre>if (ptr != NULL) {
    // Safe to use *ptr
}</pre>

                        <p class="font-medium mb-2 text-indigo-950">What if We Don't Get Null Pointers?</p>
                        <p>If null pointers didn't exist, debugging would be significantly harder. Null pointers provide a clear "invalid state" signal. Without them, pointers might point to random memory addresses, causing subtle bugs that are much harder to track than obvious crashes.</p>
                    </div>
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <!-- Empty space for future content or visualization -->
                     <div class="max-w-4xl mx-auto mt-8">
  <!-- Code Box -->
  <pre class="code-box bg-gray-900 text-green-200 p-4 rounded-lg font-mono">
int main() {
  <span class="bg-yellow-300 text-black px-1">int *ptr = NULL;</span>
  return 0;
}
  </pre>
  <div id="app-container" class="panel">

  <div class="start-view">
    <button data-program="byteshow" class="px-4 py-2 gap-2 mt-4 w-full bg-green-500 text-white rounded-lg">Start</button>
  </div>
	<div class="debugger-view">
  <!-- Buttons -->
  <div class="controls flex gap-2 mt-4">
    <button class="run-to-end-btn px-4 py-2 bg-blue-500 text-white rounded-lg">Run to End</button>
    <button class="step-btn px-4 py-2 bg-green-500 text-white rounded-lg">Step Over</button>
	<button class="stop-btn px-4 py-2 bg-red-500 text-white rounded-lg">Stop</button>
    <button class="reset-btn px-4 py-2 bg-teal-500 text-white rounded-lg">Reset</button>
  </div>

  <!-- Visualization -->
  <div class="memory-container mt-6 p-4 bg-gray-100 rounded-lg border">
    <h3 class="font-bold mb-2">Memory Visualization</h3>
    <div class="flex gap-8">
      <!-- Stack -->
      <div class="stack-table">
        <h4 class="underline">Stack</h4>
        <div class="border p-2 rounded bg-white">main()</div>
        <div class="border p-2 rounded bg-white">ptr → 0x7fff</div>
      </div>
      <!-- Heap -->
      <div class = "heap-table">
        <h4 class="underline">Heap</h4>
        <div class="border p-2 rounded bg-white">0x7fff : 42</div>
      </div>
    </div>
  </div>
  </div>
  </div> <!-- App container-->
  <div id="error-message" style="color: red; display: none;"></div>
</div>


                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <!-- Empty space for future content or visualization -->
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Memory Layout: Stack vs Heap</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">The Stack:</p>
                        <p class="mb-4">A fast, organized memory region that grows and shrinks automatically. Local variables and function parameters live here. It's like a stack of plates - last in, first out (LIFO).</p>

                        <p class="font-medium mb-2 text-indigo-950">The Heap:</p>
                        <p class="mb-4">A larger, flexible memory region for dynamic allocation. You manually allocate (malloc) and free memory here. Think of it as a warehouse where you can request storage space of any size.</p>

                        <p class="font-medium mb-2 text-indigo-950">Other Memory Regions:</p>
                        <ul class="list-disc pl-5 mb-4">
                            <li><strong>Code/Text Segment:</strong> Where your program instructions are stored</li>
                            <li><strong>Data Segment:</strong> Global and static variables</li>
                            <li><strong>BSS Segment:</strong> Uninitialized global variables</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Stack Frames Explained</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">What are Stack Frames?</p>
                        <p class="mb-4">Each function call creates a "frame" on the stack containing local variables, parameters, and return addresses. When a function ends, its frame is removed (popped) from the stack.</p>

                        <p class="font-medium mb-2 text-indigo-950">How Stack Frames Work:</p>
                        <ol class="list-decimal pl-5 mb-4">
                            <li>Function called → New frame pushed onto stack</li>
                            <li>Local variables allocated within this frame</li>
                            <li>Function returns → Frame popped, memory automatically freed</li>
                            <li>Control returns to previous frame</li>
                        </ol>

                        <p>This automatic cleanup is why local variables disappear when functions end.</p>
                    </div>
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <!-- Empty space for future content or visualization -->
                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <!-- Empty space for future content or visualization -->
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Why Arrays are Stored in Heap for Function Calls</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">The Problem with Stack Arrays:</p>
                        <p class="mb-4">Stack has limited space (usually a few MB). Large arrays can cause stack overflow. Also, stack variables are automatically destroyed when functions return.</p>

                        <p class="font-medium mb-2 text-indigo-950">Heap Arrays for Persistence:</p>
                        <p>When you need arrays that:</p>
                        <ul class="list-disc pl-5 mb-4">
                            <li>Survive beyond function scope</li>
                            <li>Are very large in size</li>
                            <li>Need dynamic sizing</li>
                            <li>Should be shared between functions</li>
                        </ul>
                        <p>You allocate them on the heap using malloc/new. This gives you control over their lifetime but requires manual memory management.</p>
                    </div>
                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Memory Alignment: Understanding 0x12345678</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">What is Memory Alignment?</p>
                        <p class="mb-4">Modern processors read memory in chunks (usually 4 or 8 bytes). Aligned addresses are multiples of these chunk sizes.</p>

                        <p class="font-medium mb-2 text-indigo-950">Is 0x12345678 Aligned?</p>
                        <p class="mb-4">This address (305,419,896 in decimal) is divisible by 4 and 8, so it IS aligned for both 32-bit and 64-bit systems. Aligned addresses end in specific patterns:</p>
                        <ul class="list-disc pl-5 mb-4">
                            <li>4-byte alignment: addresses end in 0, 4, 8, C (in hex)</li>
                            <li>8-byte alignment: addresses end in 0, 8 (in hex)</li>
                        </ul>

                        <p class="font-medium mb-2 text-indigo-950">Why Alignment Matters:</p>
                        <p>Aligned memory access is faster because the processor can read data in a single operation rather than multiple partial reads.</p>
                    </div>
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <!-- Empty space for future content or visualization -->
                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row mb-16">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <!-- Empty space for future content or visualization -->
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Endianness: Big vs Little Endian</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">What is Endianness?</p>
                        <p class="mb-4">The order in which bytes of multi-byte data are stored in memory.</p>

                        <p class="font-medium mb-2 text-indigo-950">Little Endian:</p>
                        <p class="mb-4">Stores the least significant byte first. For number 0x12345678:</p>
                        <ul class="list-disc pl-5 mb-4">
                            <li>Memory: [0x78][0x56][0x34][0x12]</li>
                            <li>Called "seeing in reverse" because the bytes appear backwards from how we write numbers</li>
                        </ul>

                        <p class="font-medium mb-2 text-indigo-950">Big Endian:</p>
                        <p class="mb-4">Stores the most significant byte first. For number 0x12345678:</p>
                        <ul class="list-disc pl-5 mb-4">
                            <li>Memory: [0x12][0x34][0x56][0x78]</li>
                            <li>Matches how we naturally write numbers left-to-right</li>
                        </ul>

                        <p class="font-medium mb-2 text-indigo-950">Why Little Endian is "Efficient":</p>
                        <ol class="list-decimal pl-5 mb-4">
                            <li><strong>Easier arithmetic:</strong> When adding numbers, you start from the least significant digit (rightmost). Little endian puts this at the lowest memory address.</li>
                            <li><strong>Type casting:</strong> Converting between different integer sizes is simpler when the least significant bytes are at consistent positions.</li>
                            <li><strong>Historical reasons:</strong> Early Intel processors used little endian, and x86 architecture dominated personal computing.</li>
                        </ol>

                        <p class="font-medium mb-2 text-indigo-950">Why Big Endian Isn't Called "Reverse":</p>
                        <p>Big endian follows human reading convention (most significant first), so it feels "natural" and doesn't need a qualifier like "reverse."</p>
                    </div>
                </div>
            </div>

            <div class="entire-row flex flex-col md:flex-row">
                <div class="left-stuff md:w-1/2 md:pr-4 mb-6 md:mb-0">
                    <h2 class="text-2xl md:text-3xl sansation-bold-italic  mb-4 text-stone-900">Memory Visualization Tips</h2>
                    <div class="bg-teal-300 bg-opacity-20 rounded-xl p-6 content-block">
                        <p class="font-medium mb-2 text-indigo-950">Address Visualization:</p>
                        <p class="mb-4">Think of memory as a long street with numbered houses. Each house (memory location) can hold data, and pointers are just the house numbers.</p>

                        <p class="font-medium mb-2 text-indigo-950">Stack Growth:</p>
                        <p class="mb-4">Visualize the stack growing downward (from high to low addresses) in most systems, like building blocks falling down.</p>

                        <p class="font-medium mb-2 text-indigo-950">Heap Fragmentation:</p>
                        <p class="mb-4">Picture the heap like a parking lot where cars (data) of different sizes park and leave, creating gaps that need management.</p>

                        <p class="font-medium mb-2 text-indigo-950">Alignment Visualization:</p>
                        <p>Imagine memory as a grid where certain data types must start at grid intersections for optimal access speed.</p>
                    </div>
                </div>
                <div class="right-stuff md:w-1/2 md:pl-4">
                    <!-- Empty space for future content or visualization -->
                </div>
            </div>
        </div>
	  <script src="https://cdn.tailwindcss.com"></script>
	  <script src="/static/js/script.js"></script>
    </body>
</html>
